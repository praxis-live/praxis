/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright 2010 Neil C Smith.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; either version 2.1 of the License,
 * or (at your option) any later version.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this work; if not, see http://www.gnu.org/licenses/
 * 
 * 
 * Please visit http://neilcsmith.net if you need additional information or
 * have any questions.
 *
 */
package org.jaudiolibs.jnajack.lowlevel;

import com.sun.jna.Memory;
import com.sun.jna.Native;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;

/**
 * JNA wrapper to the JACK library.
 *
 * Partly edited version of code automatically generated by JNAerator.
 *
 * @author Neil C Smith
 */
public interface JackLibrary extends com.sun.jna.Library {

    /**
     * Reference to an instance of JackLibrary
     */
//    public JackLibrary INSTANCE = (JackLibrary) Native.loadLibrary("jacksss", JackLibrary.class);
//    public JackLibrary INSTANCE = (JackLibrary) Native.synchronizedLibrary((JackLibrary)Native.loadLibrary("jack", JackLibrary.class));
    /**
     * <i>native declaration : ./jack/types.h:429</i>
     * enum values
     */
    public static interface jack_transport_state_t {

        /**
         * the order matters for binary compatibility
         * < Transport halted
         */
        public static final int JackTransportStopped = 0;
        /// < Transport playing
        public static final int JackTransportRolling = 1;
        /// < For OLD_TRANSPORT, now ignored
        public static final int JackTransportLooping = 2;
        /// < Waiting for sync ready
        public static final int JackTransportStarting = 3;
        /// < Waiting for sync ready on the network
        public static final int JackTransportNetStarting = 4;
    }

    /**
     * <i>native declaration : ./jack/types.h:445</i>
     * enum values
     */
    public static interface jack_position_bits_t {
        /// < Bar, Beat, Tick

        public static final int JackPositionBBT = 16;
        /// < External timecode
        public static final int JackPositionTimecode = 32;
        /// < Frame offset of BBT information
        public static final int JackBBTFrameOffset = 64;
        /// < audio frames per video frame
        public static final int JackAudioVideoRatio = 128;
        /// < frame offset of first video frame
        public static final int JackVideoFrameOffset = 256;
    }

    /**
     * <i>native declaration : ./jack/types.h:597</i>
     * enum values
     */
    public static interface jack_transport_bits_t {
        /// < Transport state

        public static final int JackTransportState = 1;
        /// < Frame number
        public static final int JackTransportPosition = 2;
        /// < Loop boundaries (ignored)
        public static final int JackTransportLoop = 4;
        /// < SMPTE (ignored)
        public static final int JackTransportSMPTE = 8;
        /// < Bar, Beat, Tick
        public static final int JackTransportBBT = 16;
    }

    /**
     * A port has a set of flags that are formed by AND-ing together the
     *  desired values from the list below. The flags "JackPortIsInput" and
     *  "JackPortIsOutput" are mutually exclusive and it is an error to use
     *  them both.
     * <i>native declaration : ./jack/types.h:244</i>
     * enum values
     */
    public static interface JackPortFlags {

        /**
         * if JackPortIsInput is set, then the port can receive
         * data.
         */
        public static final int JackPortIsInput = 1;
        /**
         * if JackPortIsOutput is set, then data can be read from
         * the port.
         */
        public static final int JackPortIsOutput = 2;
        /**
         * if JackPortIsPhysical is set, then the port corresponds
         * to some kind of physical I/O connector.
         */
        public static final int JackPortIsPhysical = 4;
        /**
         * if JackPortCanMonitor is set, then a call to
         * jack_port_request_monitor() makes sense.
         * * Precisely what this means is dependent on the client. A typical
         * result of it being called with TRUE as the second argument is
         * that data that would be available from an output port (with
         * JackPortIsPhysical set) is sent to a physical output connector
         * as well, so that it can be heard/seen/whatever.
         * * Clients that do not control physical interfaces
         * should never create ports with this bit set.
         */
        public static final int JackPortCanMonitor = 8;
        /**
         * JackPortIsTerminal means:
         * *	for an input port: the data received by the port
         *                    will not be passed on or made
         * 	           available at any other port
         * * for an output port: the data available at the port
         *                    does not originate from any other port
         * * Audio synthesizers, I/O hardware interface clients, HDR
         * systems are examples of clients that would set this flag for
         * their ports.
         */
        public static final int JackPortIsTerminal = 16;
    }

    /**
     * @ref jack_options_t bits
     * <i>native declaration : ./jack/types.h:299</i>
     * enum values
     */
    public static interface JackOptions {
        /// Null value to use when no option bits are needed.

        public static final int JackNullOption = 0;
        /**
         * Do not automatically start the JACK server when it is not
         * already running.  This option is always selected if
         * \$JACK_NO_START_SERVER is defined in the calling process
         * environment.
         */
        public static final int JackNoStartServer = 1;
        /**
         * Use the exact client name requested.  Otherwise, JACK
         * automatically generates a unique one, if needed.
         */
        public static final int JackUseExactName = 2;
        /// Open with optional <em>(char *) server_name</em> parameter.
        public static final int JackServerName = 4;
        /**
         * Load internal client from optional <em>(char *)
         * load_name</em>.  Otherwise use the @a client_name.
         */
        public static final int JackLoadName = 8;
        /**
         * Pass optional <em>(char *) load_init</em> string to the
         * jack_initialize() entry point of an internal client.
         */
        public static final int JackLoadInit = 16;
    }

    /**
     * @ref jack_status_t bits
     * <i>native declaration : ./jack/types.h:353</i>
     * enum values
     */
    public static interface JackStatus {
        /// Overall operation failed.

        public static final int JackFailure = 1;
        /// The operation contained an invalid or unsupported option.
        public static final int JackInvalidOption = 2;
        /**
         * The desired client name was not unique.  With the @ref
         * JackUseExactName option this situation is fatal.  Otherwise,
         * the name was modified by appending a dash and a two-digit
         * number in the range "-01" to "-99".  The
         * jack_get_client_name() function will return the exact string
         * that was used.  If the specified @a client_name plus these
         * extra characters would be too long, the open fails instead.
         */
        public static final int JackNameNotUnique = 4;
        /**
         * The JACK server was started as a result of this operation.
         * Otherwise, it was running already.  In either case the caller
         * is now connected to jackd, so there is no race condition.
         * When the server shuts down, the client will find out.
         */
        public static final int JackServerStarted = 8;
        /// Unable to connect to the JACK server.
        public static final int JackServerFailed = 16;
        /// Communication error with the JACK server.
        public static final int JackServerError = 32;
        /// Requested client does not exist.
        public static final int JackNoSuchClient = 64;
        /// Unable to load internal client
        public static final int JackLoadFailure = 128;
        /// Unable to initialize client
        public static final int JackInitFailure = 256;
        /// Unable to access shared memory
        public static final int JackShmFailure = 512;
        /// Client's protocol version does not match
        public static final int JackVersionError = 1024;
    }
    /**
     * define
     * SKIPPED:
     * <i>native declaration : ./jack/types.h</i>
     * (JackPositionBBT | JackPositionTimecode)
     */
    /**
     * define
     * SKIPPED:
     * <i>native declaration : ./jack/types.h</i>
     * (JackLoadInit | JackLoadName | JackUseExactName)
     */
    /// <i>native declaration : ./jack/types.h</i>
    public static final java.lang.String JACK_DEFAULT_MIDI_TYPE = "8 bit raw midi";
    /// <i>native declaration : ./jack/types.h</i>
    public static final java.lang.String JACK_DEFAULT_AUDIO_TYPE = "32 bit float mono audio";
    /// <i>native declaration : ./jack/types.h</i>
    public static final int JACK_LOAD_INIT_LIMIT = 1024;
    /**
     * define
     * SKIPPED:
     * <i>native declaration : ./jack/types.h</i>
     * (JackServerName | JackNoStartServer | JackUseExactName)
     */
    /// <i>native declaration : ./jack/types.h</i>
    public static final long JACK_MAX_FRAMES = (4294967295L);
    /// <i>native declaration : ./jack/types.h:458</i>

    public static class jack_position_t extends com.sun.jna.Structure {
        /// Allocate a new jack_position_t struct on the heap

        public jack_position_t() {
        }
        /// Cast data at given memory location (pointer + offset) as an existing jack_position_t struct

        public jack_position_t(com.sun.jna.Pointer pointer, int offset) {
            super();
            useMemory(pointer, offset);
            read();
        }
        /// Create an instance that shares its memory with another jack_position_t instance

        public jack_position_t(jack_position_t struct) {
            this(struct.getPointer(), 0);
        }

        public static class ByReference extends jack_position_t implements com.sun.jna.Structure.ByReference {
            /// Allocate a new jack_position_t.ByRef struct on the heap

            public ByReference() {
            }
            /// Create an instance that shares its memory with another jack_position_t instance

            public ByReference(jack_position_t struct) {
                super(struct.getPointer(), 0);
            }
        }

        public static class ByValue extends jack_position_t implements com.sun.jna.Structure.ByValue {
            /// Allocate a new jack_position_t.ByVal struct on the heap

            public ByValue() {
            }
            /// Create an instance that shares its memory with another jack_position_t instance

            public ByValue(jack_position_t struct) {
                super(struct.getPointer(), 0);
            }
        }
        /**
         * these four cannot be set from clients: the server sets them
         * < unique ID
         */
        public long unique_1;
        /// Conversion Error : _jack_time_t
        /// < current frame rate (per second)
        public int frame_rate;
        /// < frame number, always present
        public int frame;
        /**
         * @see jack_position_bits_t
         * < which other fields are valid
         */
        public int valid;
        /**
         * JackPositionBBT fields:
         * < current bar
         */
        public int bar;
        /// < current beat-within-bar
        public int beat;
        /// < current tick-within-beat
        public int tick;
        public double bar_start_tick;
        /// < time signature "numerator"
        public float beats_per_bar;
        /// < time signature "denominator"
        public float beat_type;
        public double ticks_per_beat;
        public double beats_per_minute;
        /**
         * JackPositionTimecode fields:	(EXPERIMENTAL: could change)
         * < current time in seconds
         */
        public double frame_time;
        /**
         * < next sequential frame_time
         * (unless repositioned)
         */
        public double next_time;
        /**
         * JackBBTFrameOffset fields:
         * < frame offset for the BBT fields
         * (the given bar, beat, and tick
         * values actually refer to a time
         * frame_offset frames before the
         * start of the cycle), should
         * be assumed to be 0 if
         * JackBBTFrameOffset is not
         * set. If JackBBTFrameOffset is
         * set and this value is zero, the BBT
         * time refers to the first frame of this
         * cycle. If the value is positive,
         * the BBT time refers to a frame that
         * many frames before the start of the
         * cycle.
         */
        public int bbt_offset;
        /**
         * < number of audio frames
         * per video frame. Should be assumed
         * zero if JackAudioVideoRatio is not
         * set. If JackAudioVideoRatio is set
         * and the value is zero, no video
         * data exists within the JACK graph
         */
        public float audio_frames_per_video_frame;
        /**
         * < audio frame at which the first video
         * frame in this cycle occurs. Should
         * be assumed to be 0 if JackVideoFrameOffset
         * is not set. If JackVideoFrameOffset is
         * set, but the value is zero, there is
         * no video frame within this cycle.
         */
        public int video_offset;
        /**
         * For binary compatibility, new fields should be allocated from
         * this padding area with new valid bits controlling access, so
         * the existing structure size and offsets are preserved.
         */
        public int[] padding = new int[(7)];
        /**
         * When (unique_1 == unique_2) the contents are consistent.
         * < unique ID
         */
        public long unique_2;
    }
    /// <i>native declaration : ./jack/types.h:613</i>

    public static class jack_transport_info_t extends com.sun.jna.Structure {
        /// Allocate a new jack_transport_info_t struct on the heap

        public jack_transport_info_t() {
        }
        /// Cast data at given memory location (pointer + offset) as an existing jack_transport_info_t struct

        public jack_transport_info_t(com.sun.jna.Pointer pointer, int offset) {
            super();
            useMemory(pointer, offset);
            read();
        }
        /// Create an instance that shares its memory with another jack_transport_info_t instance

        public jack_transport_info_t(jack_transport_info_t struct) {
            this(struct.getPointer(), 0);
        }

        public static class ByReference extends jack_transport_info_t implements com.sun.jna.Structure.ByReference {
            /// Allocate a new jack_transport_info_t.ByRef struct on the heap

            public ByReference() {
            }
            /// Create an instance that shares its memory with another jack_transport_info_t instance

            public ByReference(jack_transport_info_t struct) {
                super(struct.getPointer(), 0);
            }
        }

        public static class ByValue extends jack_transport_info_t implements com.sun.jna.Structure.ByValue {
            /// Allocate a new jack_transport_info_t.ByVal struct on the heap

            public ByValue() {
            }
            /// Create an instance that shares its memory with another jack_transport_info_t instance

            public ByValue(jack_transport_info_t struct) {
                super(struct.getPointer(), 0);
            }
        }
        /// < current frame rate (per second)
        public int frame_rate;
        /// Conversion Error : _jack_time_t
        /**
         * @see jack_transport_bits_t
         * < which fields are legal to read
         */
        public int valid;
        /// @see jack_transport_state_t
        public int transport_state;
        public int frame;
        public int loop_start;
        public int loop_end;
        /// < SMPTE offset (from frame 0)
        public com.sun.jna.NativeLong smpte_offset;
        /// < 29.97, 30, 24 etc.
        public float smpte_frame_rate;
        public int bar;
        public int beat;
        public int tick;
        public double bar_start_tick;
        public float beats_per_bar;
        public float beat_type;
        public double ticks_per_beat;
        public double beats_per_minute;
    }

    /**
     * Prototype for the client supplied function that is called
     * by the engine anytime there is work to be done.
     * * @pre nframes == jack_get_buffer_size()
     * @pre nframes == pow(2,x)
     * * @param nframes number of frames to process
     * @param arg pointer to a client supplied structure
     * * @return zero on success, non-zero on error
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackProcessCallback extends com.sun.jna.Callback {

        int invoke(int nframes);//, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client thread routine called
     * by the engine when the client is inserted in the graph.
     * * @param arg pointer to a client supplied structure
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackThreadCallback extends com.sun.jna.Callback {

        com.sun.jna.Pointer invoke(com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * once after the creation of the thread in which other
     * callbacks will be made. Special thread characteristics
     * can be set from this callback, for example. This is a
     * highly specialized callback and most clients will not
     * and should not use it.
     * * @param arg pointer to a client supplied structure
     * * @return void
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackThreadInitCallback extends com.sun.jna.Callback {

        void invoke(com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * whenever the processing graph is reordered.
     * * @param arg pointer to a client supplied structure
     * * @return zero on success, non-zero on error
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackGraphOrderCallback extends com.sun.jna.Callback {

        int invoke(com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client-supplied function that is called whenever
     * an xrun has occured.
     * * @see jack_get_xrun_delayed_usecs()
     * * @param arg pointer to a client supplied structure
     * * @return zero on success, non-zero on error
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackXRunCallback extends com.sun.jna.Callback {

        int invoke(com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the @a bufsize_callback that is invoked whenever the
     * JACK engine buffer size changes.  Although this function is called
     * in the JACK process thread, the normal process cycle is suspended
     * during its operation, causing a gap in the audio flow.  So, the @a
     * bufsize_callback can allocate storage, touch memory not previously
     * referenced, and perform other operations that are not realtime
     * safe.
     * * @param nframes buffer size
     * @param arg pointer supplied by jack_set_buffer_size_callback().
     * * @return zero on success, non-zero on error
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackBufferSizeCallback extends com.sun.jna.Callback {

        int invoke(int nframes, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * when the engine sample rate changes.
     * * @param nframes new engine sample rate
     * @param arg pointer to a client supplied structure
     * * @return zero on success, non-zero on error
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackSampleRateCallback extends com.sun.jna.Callback {

        int invoke(int nframes, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * whenever a port is registered or unregistered.
     * * @param arg pointer to a client supplied structure
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackPortRegistrationCallback extends com.sun.jna.Callback {

        void invoke(int port, int int1, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * whenever a client is registered or unregistered.
     * * @param name a null-terminated string containing the client name
     * @param register non-zero if the client is being registered,
     *                     zero if the client is being unregistered
     * @param arg pointer to a client supplied structure
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackClientRegistrationCallback extends com.sun.jna.Callback {

        /**
         * 
         * @param name a null-terminated string containing the client name
         * @param register non-zero if the client is being registered,
         *                     zero if the client is being unregistered
         * @param arg pointer to a client supplied structure
         */
        void invoke(com.sun.jna.ptr.ByteByReference name, int register, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * whenever a client is registered or unregistered.
     * * @param a one of two ports connected or disconnected
     * @param b one of two ports connected or disconnected
     * @param connect non-zero if ports were connected
     *                    zero if ports were disconnected
     * @param arg pointer to a client supplied data
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackPortConnectCallback extends com.sun.jna.Callback {

        /**
         *
         * @param a one of two ports connected or disconnected
         * @param b one of two ports connected or disconnected
         * @param connect non-zero if ports were connected
         *                    zero if ports were disconnected
         * @param arg pointer to a client supplied data
         */
        void invoke(int a, int b, int connect, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * whenever the port name has been changed.
     * * @param port the port that has been renamed
     * @param new_name the new name
     * @param arg pointer to a client supplied structure
     * * @return zero on success, non-zero on error
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackPortRenameCallback extends com.sun.jna.Callback {

        int invoke(int port, com.sun.jna.ptr.ByteByReference new_name, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * whenever jackd starts or stops freewheeling.
     * * @param starting non-zero if we start starting to freewheel, zero otherwise
     * @param arg pointer to a client supplied structure
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackFreewheelCallback extends com.sun.jna.Callback {

        void invoke(int starting, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the client supplied function that is called
     * whenever jackd is shutdown.
     * * @param arg pointer to a client supplied structure
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackShutdownCallback extends com.sun.jna.Callback {

        void invoke(com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the @a sync_callback defined by slow-sync clients.
     * When the client is active, this callback is invoked just before
     * process() in the same thread.  This occurs once after registration,
     * then subsequently whenever some client requests a new position, or
     * the transport enters the ::JackTransportStarting state.  This
     * realtime function must not wait.
     * * The transport @a state will be:
     * *   - ::JackTransportStopped when a new position is requested;
     *   - ::JackTransportStarting when the transport is waiting to start;
     *   - ::JackTransportRolling when the timeout has expired, and the
     *   position is now a moving target.
     * * @param state current transport state.
     * @param pos new transport position.
     * @param arg the argument supplied by jack_set_sync_callback().
     * * @return TRUE (non-zero) when ready to roll.
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackSyncCallback extends com.sun.jna.Callback {
        /// @param state @see jack_transport_state_t

        int invoke(int state, jack_position_t pos, com.sun.jna.Pointer arg);
    }

    /**
     * Prototype for the @a timebase_callback used to provide extended
     * position information.  Its output affects all of the following
     * process cycle.  This realtime function must not wait.
     * * This function is called immediately after process() in the same
     * thread whenever the transport is rolling, or when any client has
     * requested a new position in the previous cycle.  The first cycle
     * after jack_set_timebase_callback() is also treated as a new
     * position, or the first cycle after jack_activate() if the client
     * had been inactive.
     * * The timebase master may not use its @a pos argument to set @a
     * pos->frame.  To change position, use jack_transport_reposition() or
     * jack_transport_locate().  These functions are realtime-safe, the @a
     * timebase_callback can call them directly.
     * * @param state current transport state.
     * @param nframes number of frames in current period.
     * @param pos address of the position structure for the next cycle; @a
     * pos->frame will be its frame number.  If @a new_pos is FALSE, this
     * structure contains extended position information from the current
     * cycle.  If TRUE, it contains whatever was set by the requester.
     * The @a timebase_callback's task is to update the extended
     * information here.
     * @param new_pos TRUE (non-zero) for a newly requested @a pos, or for
     * the first cycle after the @a timebase_callback is defined.
     * @param arg the argument supplied by jack_set_timebase_callback().
     * <i>native declaration : ./jack/types.h</i>
     */
    public interface JackTimebaseCallback extends com.sun.jna.Callback {
        /// @param state @see jack_transport_state_t

        /**
         *
         * @param state
         * @param nframes
         * @param pos
         * @param new_pos
         * @param arg
         */
        void invoke(int state, int nframes, jack_position_t pos, int new_pos, com.sun.jna.Pointer arg);
    }
    /// <i>native declaration : jack/jack.h:998</i>

    public interface jack_error_callback extends com.sun.jna.Callback {

        void invoke(com.sun.jna.ptr.ByteByReference msg);
    }
    /// <i>native declaration : jack/jack.h:1006</i>

    public interface func extends com.sun.jna.Callback {

        void invoke(com.sun.jna.ptr.ByteByReference charPtr1);
    }
    /// <i>native declaration : jack/jack.h:1016</i>

    public interface jack_info_callback extends com.sun.jna.Callback {

        void invoke(com.sun.jna.ptr.ByteByReference msg);
    }
    /// <i>native declaration : jack/jack.h:1021</i>

    public interface func2 extends com.sun.jna.Callback {

        void invoke(com.sun.jna.ptr.ByteByReference charPtr1);
    }

//    /**
//     * Call this function to get version of the JACK, in form of several numbers
//     * * @param major_ptr pointer to variable receiving major version of JACK.
//     * * @param minor_ptr pointer to variable receiving minor version of JACK.
//     * * @param major_ptr pointer to variable receiving micro version of JACK.
//     * * @param major_ptr pointer to variable receiving protocol version of JACK.
//     * Original signature : <code>void jack_get_version(int*, int*, int*, int*)</code>
//     * <i>native declaration : jack/jack.h:47</i>
//     */
////	// @com.ochafik.lang.jnaerator.Mangling({"_Z16jack_get_versionPiPiPiPi", "?jack_get_version@@YAXPAHPAHPAHPAH@Z"})
//    void jack_get_version(java.nio.IntBuffer major_ptr, java.nio.IntBuffer minor_ptr, java.nio.IntBuffer micro_ptr, java.nio.IntBuffer proto_ptr);
//    void jack_get_version(IntByReference major, IntByReference minor,
//            IntByReference micro, IntByReference protocol);
//    /**
//     * Call this function to get version of the JACK, in form of a string
//     * * @return Human readable string describing JACK version being used.
//     * Original signature : <code>char* jack_get_version_string()</code>
//     * <i>native declaration : jack/jack.h:60</i>
//     */
////	// @com.ochafik.lang.jnaerator.Mangling({"_Z23jack_get_version_stringv", "?jack_get_version_string@@YAPADXZ"})
//    String jack_get_version_string();

    /**
     * Open an external client session with a JACK server.  This interface
     * is more complex but more powerful than jack_client_new().  With it,
     * clients may choose which of several servers to connect, and control
     * whether and how to start the server automatically, if it was not
     * already running.  There is also an option for JACK to generate a
     * unique client name, when necessary.
     * * @param client_name of at most jack_client_name_size() characters.
     * The name scope is local to each server.  Unless forbidden by the
     * @ref JackUseExactName option, the server will modify this name to
     * create a unique variant, if needed.
     * * @param options formed by OR-ing together @ref JackOptions bits.
     * Only the @ref JackOpenOptions bits are allowed.
     * * @param status (if non-NULL) an address for JACK to return
     * information from the open operation.  This status word is formed by
     * OR-ing together the relevant @ref JackStatus bits.
     * *
     * <b>Optional parameters:</b> depending on corresponding [@a options
     * bits] additional parameters may follow @a status (in this order).
     * * @arg [@ref JackServerName] <em>(char *) server_name</em> selects
     * from among several possible concurrent server instances.  Server
     * names are unique to each user.  If unspecified, use "default"
     * unless \$JACK_DEFAULT_SERVER is defined in the process environment.
     * * @return Opaque client handle if successful.  If this is NULL, the
     * open operation failed, @a *status includes @ref JackFailure and the
     * caller is not a JACK client.
     * Original signature : <code>jack_client_t* jack_client_open(const char*, jack_options_t, jack_status_t*, null)</code>
     * <i>native declaration : jack/jack.h:96</i>
     * @param options @see JackOptions
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"?jack_client_open@@YAPA12_jack_clientPADW4JackOptions@@PAW4JackStatus@@X@Z"})
//    _jack_client jack_client_open(java.lang.String client_name, int options, com.sun.jna.Pointer status, Object... varargs);
    _jack_client jack_client_open(java.lang.String client_name, int options, IntByReference status);

    /**
     * Disconnects an external client from a JACK server.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_client_close(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:112</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z17jack_client_closeP12_jack_client", "?jack_client_close@@YAHPA12_jack_client@Z"})
    int jack_client_close(_jack_client client);

    /**
     * @return the maximum number of characters in a JACK client name
     * including the final NULL character.  This value is a constant.
     * Original signature : <code>int jack_client_name_size()</code>
     * <i>native declaration : jack/jack.h:118</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z21jack_client_name_sizev", "?jack_client_name_size@@YAHXZ"})
    int jack_client_name_size();

    /**
     * @return pointer to actual client name.  This is useful when @ref
     * JackUseExactName is not specified on open and @ref
     * JackNameNotUnique status was returned.  In that case, the actual
     * name will differ from the @a client_name requested.
     * Original signature : <code>char* jack_get_client_name(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:126</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z20jack_get_client_nameP12_jack_client", "?jack_get_client_name@@YAPADPA12_jack_client@Z"})
//    com.sun.jna.ptr.ByteByReference jack_get_client_name(_jack_client client);
    String jack_get_client_name(_jack_client client);

//    /**
//     * @return pid of client. If not available, 0 will be returned.
//     * Original signature : <code>int jack_get_client_pid(const char*)</code>
//     * <i>native declaration : jack/jack.h:131</i>
//     */
////	// @com.ochafik.lang.jnaerator.Mangling({"_Z19jack_get_client_pidPKc", "?jack_get_client_pid@@YAHPAD@Z"})
//    int jack_get_client_pid(java.lang.String name);

    /**
     * @param client pointer to JACK client structure.
     * * Check if the JACK subsystem is running with -R (--realtime).
     * * @return 1 if JACK is running realtime, 0 otherwise
     * Original signature : <code>int jack_is_realtime(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:172</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z16jack_is_realtimeP12_jack_client", "?jack_is_realtime@@YAHPA12_jack_client@Z"})
    int jack_is_realtime(_jack_client client);

    /**
     * @param client pointer to JACK client structure.
     * @param function The jack_shutdown function pointer.
     * @param arg The arguments for the jack_shutdown function.
     * * Register a function (and argument) to be called if and when the
     * JACK server shuts down the client thread.  The function must
     * be written as if it were an asynchonrous POSIX signal
     * handler --- use only async-safe functions, and remember that it
     * is executed from another thread.  A typical function might
     * set a flag or write to a pipe so that the rest of the
     * application knows that the JACK client thread has shut
     * down.
     * * NOTE: clients do not need to call this.  It exists only
     * to help more complex clients understand what is going
     * on.  It should be called before jack_client_activate().
     * Original signature : <code>void jack_on_shutdown(jack_client_t*, JackShutdownCallback, void*)</code>
     * <i>native declaration : jack/jack.h:192</i>
     */
    void jack_on_shutdown(_jack_client client, JackShutdownCallback shutdown_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the Jack server to call @a process_callback whenever there is
     * work be done, passing @a arg as the second argument.
     * * The code in the supplied function must be suitable for real-time
     * execution.  That means that it cannot call functions that might
     * block for a long time. This includes malloc, free, printf,
     * pthread_mutex_lock, sleep, wait, poll, select, pthread_join,
     * pthread_cond_wait, etc, etc. See
     * http://jackit.sourceforge.net/docs/design/design.html#SECTION00411000000000000000
     * for more information.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code.
     * Original signature : <code>int jack_set_process_callback(jack_client_t*, JackProcessCallback, void*)</code>
     * <i>native declaration : jack/jack.h:212</i>
     */
    int jack_set_process_callback(_jack_client client, JackProcessCallback process_callback, com.sun.jna.Pointer arg);

    /**
     * Wait until this JACK client should process data.
     *
     * @param client - pointer to a JACK client structure
     * * @return the number of frames of data to process
     * Original signature : <code>jack_nframes_t jack_cycle_wait(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:231</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z15jack_cycle_waitP12_jack_client", "?jack_cycle_wait@@YA8uint32_tPA12_jack_client@Z"})
    int jack_cycle_wait(_jack_client client);

    /**
     * Signal next clients in the graph.
     *
     * @param client - pointer to a JACK client structure
     * @param status - if non-zero, calling thread should exit
     * Original signature : <code>void jack_cycle_signal(jack_client_t*, int)</code>
     * <i>native declaration : jack/jack.h:239</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z17jack_cycle_signalP12_jack_clienti", "?jack_cycle_signal@@YAXPA12_jack_clientH@Z"})
    void jack_cycle_signal(_jack_client client, int status);

    /**
     * Tell the Jack server to call @a thread_callback in the RT thread.
     * Typical use are in conjunction with @a jack_cycle_wait and @ jack_cycle_signal functions.
     * The code in the supplied function must be suitable for real-time
     * execution.  That means that it cannot call functions that might
     * block for a long time. This includes malloc, free, printf,
     * pthread_mutex_lock, sleep, wait, poll, select, pthread_join,
     * pthread_cond_wait, etc, etc. See
     * http://jackit.sourceforge.net/docs/design/design.html#SECTION00411000000000000000
     * for more information.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code.
     * Original signature : <code>int jack_set_process_thread(jack_client_t*, JackThreadCallback, void*)</code>
     * <i>native declaration : jack/jack.h:257</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z23jack_set_process_threadP12_jack_client18JackThreadCallbackPv", "?jack_set_process_thread@@YAHPA12_jack_client18JackThreadCallbackPAX@Z"})
    int jack_set_process_thread(_jack_client client, JackThreadCallback thread_callback, com.sun.jna.Pointer arg);

    /**
     * Tell JACK to call @a thread_init_callback once just after
     * the creation of the thread in which all other callbacks
     * will be handled.
     * * The code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code, causing JACK
     * to remove that client from the process() graph.
     * Original signature : <code>int jack_set_thread_init_callback(jack_client_t*, JackThreadInitCallback, void*)</code>
     * <i>native declaration : jack/jack.h:273</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z29jack_set_thread_init_callbackP12_jack_client22JackThreadInitCallbackPv", "?jack_set_thread_init_callback@@YAHPA12_jack_client22JackThreadInitCallbackPAX@Z"})
    int jack_set_thread_init_callback(_jack_client client, JackThreadInitCallback thread_init_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the Jack server to call @a freewheel_callback
     * whenever we enter or leave "freewheel" mode, passing @a
     * arg as the second argument. The first argument to the
     * callback will be non-zero if JACK is entering freewheel
     * mode, and zero otherwise.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code.
     * Original signature : <code>int jack_set_freewheel_callback(jack_client_t*, JackFreewheelCallback, void*)</code>
     * <i>native declaration : jack/jack.h:293</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z27jack_set_freewheel_callbackP12_jack_client21JackFreewheelCallbackPv", "?jack_set_freewheel_callback@@YAHPA12_jack_client21JackFreewheelCallbackPAX@Z"})
    int jack_set_freewheel_callback(_jack_client client, JackFreewheelCallback freewheel_callback, com.sun.jna.Pointer arg);

    /**
     * Start/Stop JACK's "freewheel" mode.
     * * When in "freewheel" mode, JACK no longer waits for
     * any external event to begin the start of the next process
     * cycle.
     * * As a result, freewheel mode causes "faster than realtime"
     * execution of a JACK graph. If possessed, real-time
     * scheduling is dropped when entering freewheel mode, and
     * if appropriate it is reacquired when stopping.
     *
     * IMPORTANT: on systems using capabilities to provide real-time
     * scheduling (i.e. Linux kernel 2.4), if onoff is zero, this function
     * must be called from the thread that originally called jack_activate().
     * This restriction does not apply to other systems (e.g. Linux kernel 2.6
     * or OS X).
     *
     * @param client pointer to JACK client structure
     * @param onoff  if non-zero, freewheel mode starts. Otherwise
     *                  freewheel mode ends.
     * * @return 0 on success, otherwise a non-zero error code.
     * Original signature : <code>int jack_set_freewheel(jack_client_t*, int)</code>
     * <i>native declaration : jack/jack.h:321</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z18jack_set_freewheelP12_jack_clienti", "?jack_set_freewheel@@YAHPA12_jack_clientH@Z"})
    int jack_set_freewheel(_jack_client client, int onoff);

    /**
     * Change the buffer size passed to the @a process_callback.
     * * This operation stops the JACK engine process cycle, then calls all
     * registered @a bufsize_callback functions before restarting the
     * process cycle.  This will cause a gap in the audio flow, so it
     * should only be done at appropriate stopping points.
     * * @see jack_set_buffer_size_callback()
     * * @param client pointer to JACK client structure.
     * @param nframes new buffer size.  Must be a power of two.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_buffer_size(jack_client_t*, jack_nframes_t)</code>
     * <i>native declaration : jack/jack.h:338</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z20jack_set_buffer_sizeP12_jack_client8uint32_t", "?jack_set_buffer_size@@YAHPA12_jack_client8uint32_t@Z"})
    int jack_set_buffer_size(_jack_client client, int nframes);

    /**
     * Tell JACK to call @a bufsize_callback whenever the size of the the
     * buffer that will be passed to the @a process_callback is about to
     * change.  Clients that depend on knowing the buffer size must supply
     * a @a bufsize_callback before activating themselves.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @param client pointer to JACK client structure.
     * @param bufsize_callback function to call when the buffer size changes.
     * @param arg argument for @a bufsize_callback.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_buffer_size_callback(jack_client_t*, JackBufferSizeCallback, void*)</code>
     * <i>native declaration : jack/jack.h:359</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z29jack_set_buffer_size_callbackP12_jack_client22JackBufferSizeCallbackPv", "?jack_set_buffer_size_callback@@YAHPA12_jack_client22JackBufferSizeCallbackPAX@Z"})
    int jack_set_buffer_size_callback(_jack_client client, JackBufferSizeCallback bufsize_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the Jack server to call @a srate_callback whenever the system
     * sample rate changes.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_sample_rate_callback(jack_client_t*, JackSampleRateCallback, void*)</code>
     * <i>native declaration : jack/jack.h:376</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z29jack_set_sample_rate_callbackP12_jack_client22JackSampleRateCallbackPv", "?jack_set_sample_rate_callback@@YAHPA12_jack_client22JackSampleRateCallbackPAX@Z"})
    int jack_set_sample_rate_callback(_jack_client client, JackSampleRateCallback srate_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the JACK server to call @a registration_callback whenever a
     * port is registered or unregistered, passing @a arg as a parameter.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_client_registration_callback(jack_client_t*, JackClientRegistrationCallback, void*)</code>
     * <i>native declaration : jack/jack.h:393</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z37jack_set_client_registration_callbackP12_jack_client30JackClientRegistrationCallbackPv", "?jack_set_client_registration_callback@@YAHPA12_jack_client30JackClientRegistrationCallbackPAX@Z"})
    int jack_set_client_registration_callback(_jack_client jack_client_tPtr1, JackClientRegistrationCallback registration_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the JACK server to call @a registration_callback whenever a
     * port is registered or unregistered, passing @a arg as a parameter.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_port_registration_callback(jack_client_t*, JackPortRegistrationCallback, void*)</code>
     * <i>native declaration : jack/jack.h:410</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z35jack_set_port_registration_callbackP12_jack_client28JackPortRegistrationCallbackPv", "?jack_set_port_registration_callback@@YAHPA12_jack_client28JackPortRegistrationCallbackPAX@Z"})
    int jack_set_port_registration_callback(_jack_client jack_client_tPtr1, JackPortRegistrationCallback registration_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the JACK server to call @a connect_callback whenever a
     * port is connected or disconnected, passing @a arg as a parameter.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_port_connect_callback(jack_client_t*, JackPortConnectCallback, void*)</code>
     * <i>native declaration : jack/jack.h:427</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z30jack_set_port_connect_callbackP12_jack_client23JackPortConnectCallbackPv", "?jack_set_port_connect_callback@@YAHPA12_jack_client23JackPortConnectCallbackPAX@Z"})
    int jack_set_port_connect_callback(_jack_client jack_client_tPtr1, JackPortConnectCallback connect_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the JACK server to call @a rename_callback whenever a
     * port is renamed, passing @a arg as a parameter.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_port_rename_callback(jack_client_t*, JackPortRenameCallback, void*)</code>
     * <i>native declaration : jack/jack.h:444</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z29jack_set_port_rename_callbackP12_jack_client22JackPortRenameCallbackPv", "?jack_set_port_rename_callback@@YAHPA12_jack_client22JackPortRenameCallbackPAX@Z"})
//    int jack_set_port_rename_callback(_jack_client jack_client_tPtr1, JackPortRenameCallback rename_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the JACK server to call @a graph_callback whenever the
     * processing graph is reordered, passing @a arg as a parameter.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_graph_order_callback(jack_client_t*, JackGraphOrderCallback, void*)</code>
     * <i>native declaration : jack/jack.h:461</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z29jack_set_graph_order_callbackP12_jack_client22JackGraphOrderCallbackPv", "?jack_set_graph_order_callback@@YAHPA12_jack_client22JackGraphOrderCallbackPAX@Z"})
    int jack_set_graph_order_callback(_jack_client jack_client_tPtr1, JackGraphOrderCallback graph_callback, com.sun.jna.Pointer voidPtr1);

    /**
     * Tell the JACK server to call @a xrun_callback whenever there is a
     * xrun, passing @a arg as a parameter.
     * * All "notification events" are received in a seperated non RT thread,
     * the code in the supplied function does not need to be
     * suitable for real-time execution.
     * * NOTE: this function cannot be called while the client is activated
     * (after jack_activate has been called.)
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_set_xrun_callback(jack_client_t*, JackXRunCallback, void*)</code>
     * <i>native declaration : jack/jack.h:478</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z22jack_set_xrun_callbackP12_jack_client16JackXRunCallbackPv", "?jack_set_xrun_callback@@YAHPA12_jack_client16JackXRunCallbackPAX@Z"})
    int jack_set_xrun_callback(_jack_client jack_client_tPtr1, JackXRunCallback xrun_callback, com.sun.jna.Pointer arg);

    /**
     * Tell the Jack server that the program is ready to start processing
     * audio.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_activate(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:487</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z13jack_activateP12_jack_client", "?jack_activate@@YAHPA12_jack_client@Z"})
    int jack_activate(_jack_client client);

    /**
     * Tell the Jack server to remove this @a client from the process
     * graph.  Also, disconnect all ports belonging to it, since inactive
     * clients have no port connections.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_deactivate(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:496</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z15jack_deactivateP12_jack_client", "?jack_deactivate@@YAHPA12_jack_client@Z"})
    int jack_deactivate(_jack_client client);

    /**
     * Create a new port for the client. This is an object used for moving
     * data of any type in or out of the client.  Ports may be connected
     * in various ways.
     * * Each port has a short name.  The port's full name contains the name
     * of the client concatenated with a colon (:) followed by its short
     * name.  The jack_port_name_size() is the maximum length of this full
     * name.  Exceeding that will cause the port registration to fail and
     * return NULL.
     * * All ports have a type, which may be any non-NULL and non-zero
     * length string, passed as an argument.  Some port types are built
     * into the JACK API, currently only JACK_DEFAULT_AUDIO_TYPE.
     * * @param client pointer to JACK client structure.
     * @param port_name non-empty short name for the new port (not
     * including the leading @a "client_name:").
     * @param port_type port type name.  If longer than
     * jack_port_type_size(), only that many characters are significant.
     * @param flags @ref JackPortFlags bit mask.
     * @param buffer_size must be non-zero if this is not a built-in @a
     * port_type.  Otherwise, it is ignored.
     * * @return jack_port_t pointer on success, otherwise NULL.
     * Original signature : <code>jack_port_t* jack_port_register(jack_client_t*, const char*, const char*, unsigned long, unsigned long)</code>
     * <i>native declaration : jack/jack.h:524</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z18jack_port_registerP12_jack_clientPKcPKcmm", "?jack_port_register@@YAPA10_jack_portPA12_jack_clientPADPADKK@Z"})
    _jack_port jack_port_register(_jack_client client, java.lang.String port_name, java.lang.String port_type, com.sun.jna.NativeLong flags, com.sun.jna.NativeLong buffer_size);

    /**
     * Remove the port from the client, disconnecting any existing
     * connections.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_port_unregister(jack_client_t*, jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:536</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z20jack_port_unregisterP12_jack_clientP10_jack_port", "?jack_port_unregister@@YAHPA12_jack_clientPA10_jack_port@Z"})
    int jack_port_unregister(_jack_client jack_client_tPtr1, _jack_port jack_port_tPtr1);

    /**
     * This returns a pointer to the memory area associated with the
     * specified port. For an output port, it will be a memory area
     * that can be written to; for an input port, it will be an area
     * containing the data from the port's connection(s), or
     * zero-filled. if there are multiple inbound connections, the data
     * will be mixed appropriately.
     * * FOR OUTPUT PORTS ONLY : DEPRECATED in Jack 2.0 !!
     * ---------------------------------------------------
     * You may cache the value returned, but only between calls to
     * your "blocksize" callback. For this reason alone, you should
     * either never cache the return value or ensure you have
     * a "blocksize" callback and be sure to invalidate the cached
     * address from there.
     *
     * Caching output ports is DEPRECATED in Jack 2.0, due to some new optimization (like "pipelining").
     * Port buffers have to be retrieved in each callback for proper functionning.
     * Original signature : <code>void* jack_port_get_buffer(jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:557</i>
     */
    com.sun.jna.Pointer jack_port_get_buffer(_jack_port jack_port_tPtr1, int nframes);

    /**
     * @return the full name of the jack_port_t (including the @a
     * "client_name:" prefix).
     * * @see jack_port_name_size().
     * Original signature : <code>char* jack_port_name(const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:565</i>
     */
//    com.sun.jna.ptr.ByteByReference jack_port_name(_jack_port port);
    String jack_port_name(_jack_port port);

    /**
     * @return the short name of the jack_port_t (not including the @a
     * "client_name:" prefix).
     * * @see jack_port_name_size().
     * Original signature : <code>char* jack_port_short_name(const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:573</i>
     */
    com.sun.jna.ptr.ByteByReference jack_port_short_name(_jack_port port);

    /**
     * @return the @ref JackPortFlags of the jack_port_t.
     * Original signature : <code>int jack_port_flags(const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:578</i>
     */
    int jack_port_flags(_jack_port port);

    /**
     * @return the @a port type, at most jack_port_type_size() characters
     * including a final NULL.
     * Original signature : <code>char* jack_port_type(const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:584</i>
     */
    com.sun.jna.ptr.ByteByReference jack_port_type(_jack_port port);

    /**
     * @return the @a port type id.
     * Original signature : <code>jack_port_type_id_t jack_port_type_id(const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:589</i>
     */
//    int jack_port_type_id(_jack_port port);

    /**
     * @return TRUE if the jack_port_t belongs to the jack_client_t.
     * Original signature : <code>int jack_port_is_mine(const jack_client_t*, const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:594</i>
     */
    int jack_port_is_mine(_jack_client jack_client_tPtr1, _jack_port port);

    /**
     * @return number of connections to or from @a port.
     * * @pre The calling client must own @a port.
     * Original signature : <code>int jack_port_connected(const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:601</i>
     */
    int jack_port_connected(_jack_port port);

    /**
     * @return TRUE if the locally-owned @a port is @b directly connected
     * to the @a port_name.
     * * @see jack_port_name_size()
     * Original signature : <code>int jack_port_connected_to(const jack_port_t*, const char*)</code>
     * <i>native declaration : jack/jack.h:609</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z22jack_port_connected_toPK10_jack_portPKc", "?jack_port_connected_to@@YAHPA10_jack_portPAD@Z"})
    int jack_port_connected_to(_jack_port port, java.lang.String port_name);

    /**
     * @return a null-terminated array of full port names to which the @a
     * port is connected.  If none, returns NULL.
     * * The caller is responsible for calling free(3) on any non-NULL
     * returned value.
     * * @param port locally owned jack_port_t pointer.
     * * @see jack_port_name_size(), jack_port_get_all_connections()
     * Original signature : <code>char** jack_port_get_connections(const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:623</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z25jack_port_get_connectionsPK10_jack_port", "?jack_port_get_connections@@YAPAPADPA10_jack_port@Z"})
//    com.sun.jna.ptr.PointerByReference jack_port_get_connections(_jack_port port);
    Pointer jack_port_get_connections(_jack_port port);

    /**
     * @return a null-terminated array of full port names to which the @a
     * port is connected.  If none, returns NULL.
     * * The caller is responsible for calling free(3) on any non-NULL
     * returned value.
     * * This differs from jack_port_get_connections() in two important
     * respects:
     * *     1) You may not call this function from code that is
     *          executed in response to a JACK event. For example,
     *          you cannot use it in a GraphReordered handler.
     * *     2) You need not be the owner of the port to get information
     *          about its connections.
     * * @see jack_port_name_size()
     * Original signature : <code>char** jack_port_get_all_connections(const jack_client_t*, const jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:644</i>
     */
//	// @com.ochafik.lang.jnaerator.Mangling({"_Z29jack_port_get_all_connectionsPK12_jack_clientPK10_jack_port", "?jack_port_get_all_connections@@YAPAPADPA12_jack_clientPA10_jack_port@Z"})
//    com.sun.jna.ptr.PointerByReference jack_port_get_all_connections(_jack_client client, _jack_port port);
    Pointer jack_port_get_all_connections(_jack_client client, _jack_port port);

    /**
     * A client may call this on a pair of its own ports to
     * semi-permanently wire them together. This means that
     * a client that wants to direct-wire an input port to
     * an output port can call this and then no longer
     * have to worry about moving data between them. Any data
     * arriving at the input port will appear automatically
     * at the output port.
     * * The 'destination' port must be an output port. The 'source'
     * port must be an input port. Both ports must belong to
     * the same client. You cannot use this to tie ports between
     * clients. That is what a connection is for.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_port_tie(jack_port_t*, jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:663</i>
     */
    int jack_port_tie(_jack_port src, _jack_port dst);

    /**
     * This undoes the effect of jack_port_tie(). The port
     * should be same as the 'destination' port passed to
     * jack_port_tie().
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_port_untie(jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:672</i>
     */
    int jack_port_untie(_jack_port port);

    /**
     * @return the time (in frames) between data being available or
     * delivered at/to a port, and the time at which it arrived at or is
     * delivered to the "other side" of the port.  E.g. for a physical
     * audio output port, this is the time between writing to the port and
     * when the signal will leave the connector.  For a physical audio
     * input port, this is the time between the sound arriving at the
     * connector and the corresponding frames being readable from the
     * port.
     * Original signature : <code>jack_nframes_t jack_port_get_latency(jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:684</i>
     */
    int jack_port_get_latency(_jack_port port);

    /**
     * The maximum of the sum of the latencies in every
     * connection path that can be drawn between the port and other
     * ports with the @ref JackPortIsTerminal flag set.
     * Original signature : <code>jack_nframes_t jack_port_get_total_latency(jack_client_t*, jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:691</i>
     */
    int jack_port_get_total_latency(_jack_client jack_client_tPtr1, _jack_port port);

    /**
     * The port latency is zero by default. Clients that control
     * physical hardware with non-zero latency should call this
     * to set the latency to its correct value. Note that the value
     * should include any systemic latency present "outside" the
     * physical hardware controlled by the client. For example,
     * for a client controlling a digital audio interface connected
     * to an external digital converter, the latency setting should
     * include both buffering by the audio interface *and* the converter.
     * Original signature : <code>void jack_port_set_latency(jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:704</i>
     */
    void jack_port_set_latency(_jack_port jack_port_tPtr1);

    /**
     * Request a complete recomputation of a port's total latency. This
     * can be called by a client that has just changed the internal
     * latency of its port using @function jack_port_set_latency
     * and wants to ensure that all signal pathways in the graph
     * are updated with respect to the values that will be returned
     * by @function jack_port_get_total_latency.
     *
     * @return zero for successful execution of the request. non-zero
     *         otherwise.
     * Original signature : <code>int jack_recompute_total_latency(jack_client_t*, jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:717</i>
     */
    int jack_recompute_total_latency(_jack_client jack_client_tPtr1, _jack_port port);

    /**
     * Request a complete recomputation of all port latencies. This
     * can be called by a client that has just changed the internal
     * latency of its port using @function jack_port_set_latency
     * and wants to ensure that all signal pathways in the graph
     * are updated with respect to the values that will be returned
     * by @function jack_port_get_total_latency. It allows a client
     * to change multiple port latencies without triggering a
     * recompute for each change.
     *
     * @return zero for successful execution of the request. non-zero
     *         otherwise.
     * Original signature : <code>int jack_recompute_total_latencies(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:732</i>
     */
    int jack_recompute_total_latencies(_jack_client jack_client_tPtr1);

    /**
     * Modify a port's short name.  May be called at any time.  If the
     * resulting full name (including the @a "client_name:" prefix) is
     * longer than jack_port_name_size(), it will be truncated.
     * * @return 0 on success, otherwise a non-zero error code.
     * Original signature : <code>int jack_port_set_name(jack_port_t*, const char*)</code>
     * <i>native declaration : jack/jack.h:741</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z18jack_port_set_nameP10_jack_portPKc", "?jack_port_set_name@@YAHPA10_jack_portPAD@Z"})
    int jack_port_set_name(_jack_port port, java.lang.String port_name);

    /**
     * Set @a alias as an alias for @a port.  May be called at any time.
     * If the alias is longer than jack_port_name_size(), it will be truncated.
     *
     * After a successful call, and until JACK exits or
     * @function jack_port_unset_alias() is called, @alias may be
     * used as a alternate name for the port.
     * * Ports can have up to two aliases - if both are already
     * set, this function will return an error.
     * * @return 0 on success, otherwise a non-zero error code.
     * Original signature : <code>int jack_port_set_alias(jack_port_t*, const char*)</code>
     * <i>native declaration : jack/jack.h:756</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z19jack_port_set_aliasP10_jack_portPKc", "?jack_port_set_alias@@YAHPA10_jack_portPAD@Z"})
    int jack_port_set_alias(_jack_port port, java.lang.String alias);

    /**
     * Remove @a alias as an alias for @a port.  May be called at any time.
     *
     * After a successful call, @a alias can no longer be
     * used as a alternate name for the port.
     * * @return 0 on success, otherwise a non-zero error code.
     * Original signature : <code>int jack_port_unset_alias(jack_port_t*, const char*)</code>
     * <i>native declaration : jack/jack.h:766</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z21jack_port_unset_aliasP10_jack_portPKc", "?jack_port_unset_alias@@YAHPA10_jack_portPAD@Z"})
    int jack_port_unset_alias(_jack_port port, java.lang.String alias);

    /**
     * Get any aliases known for @port.
     * * @return the number of aliases discovered for the port
     * Original signature : <code>int jack_port_get_aliases(const jack_port_t*, char*[2])</code>
     * <i>native declaration : jack/jack.h:773</i>
     */
//    int jack_port_get_aliases(_jack_port port, java.nio.ByteBuffer aliases[]);

    /**
     * If @ref JackPortCanMonitor is set for this @a port, turn input
     * monitoring on or off.  Otherwise, do nothing.
     * Original signature : <code>int jack_port_request_monitor(jack_port_t*, int)</code>
     * <i>native declaration : jack/jack.h:779</i>
     */
    int jack_port_request_monitor(_jack_port port, int onoff);

    /**
     * If @ref JackPortCanMonitor is set for this @a port_name, turn input
     * monitoring on or off.  Otherwise, do nothing.
     * * @return 0 on success, otherwise a non-zero error code.
     * * @see jack_port_name_size()
     * Original signature : <code>int jack_port_request_monitor_by_name(jack_client_t*, const char*, int)</code>
     * <i>native declaration : jack/jack.h:789</i>
     */
    int jack_port_request_monitor_by_name(_jack_client client, java.lang.String port_name, int onoff);

    /**
     * If @ref JackPortCanMonitor is set for a port, this function turns
     * on input monitoring if it was off, and turns it off if only one
     * request has been made to turn it on.  Otherwise it does nothing.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_port_ensure_monitor(jack_port_t*, int)</code>
     * <i>native declaration : jack/jack.h:799</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z24jack_port_ensure_monitorP10_jack_porti", "?jack_port_ensure_monitor@@YAHPA10_jack_portH@Z"})
    int jack_port_ensure_monitor(_jack_port port, int onoff);

    /**
     * @return TRUE if input monitoring has been requested for @a port.
     * Original signature : <code>int jack_port_monitoring_input(jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:804</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z26jack_port_monitoring_inputP10_jack_port", "?jack_port_monitoring_input@@YAHPA10_jack_port@Z"})
    int jack_port_monitoring_input(_jack_port port);

    /**
     * Establish a connection between two ports.
     * * When a connection exists, data written to the source port will
     * be available to be read at the destination port.
     * * @pre The port types must be identical.
     * * @pre The @ref JackPortFlags of the @a source_port must include @ref
     * JackPortIsOutput.
     * * @pre The @ref JackPortFlags of the @a destination_port must include
     * @ref JackPortIsInput.
     * * @return 0 on success, EEXIST if the connection is already made,
     * otherwise a non-zero error code
     * Original signature : <code>int jack_connect(jack_client_t*, const char*, const char*)</code>
     * <i>native declaration : jack/jack.h:823</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z12jack_connectP12_jack_clientPKcPKc", "?jack_connect@@YAHPA12_jack_clientPADPAD@Z"})
    int jack_connect(_jack_client jack_client_tPtr1, java.lang.String source_port, java.lang.String destination_port);

    /**
     * Remove a connection between two ports.
     * * @pre The port types must be identical.
     * * @pre The @ref JackPortFlags of the @a source_port must include @ref
     * JackPortIsOutput.
     * * @pre The @ref JackPortFlags of the @a destination_port must include
     * @ref JackPortIsInput.
     * * @return 0 on success, otherwise a non-zero error code
     * Original signature : <code>int jack_disconnect(jack_client_t*, const char*, const char*)</code>
     * <i>native declaration : jack/jack.h:840</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z15jack_disconnectP12_jack_clientPKcPKc", "?jack_disconnect@@YAHPA12_jack_clientPADPAD@Z"})
    int jack_disconnect(_jack_client jack_client_tPtr1, java.lang.String source_port, java.lang.String destination_port);

    /**
     * Perform the same function as jack_disconnect() using port handles
     * rather than names.  This avoids the name lookup inherent in the
     * name-based version.
     * * Clients connecting their own ports are likely to use this function,
     * while generic connection clients (e.g. patchbays) would use
     * jack_disconnect().
     * Original signature : <code>int jack_port_disconnect(jack_client_t*, jack_port_t*)</code>
     * <i>native declaration : jack/jack.h:853</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z20jack_port_disconnectP12_jack_clientP10_jack_port", "?jack_port_disconnect@@YAHPA12_jack_clientPA10_jack_port@Z"})
    int jack_port_disconnect(_jack_client jack_client_tPtr1, _jack_port jack_port_tPtr1);

    /**
     * @return the maximum number of characters in a full JACK port name
     * including the final NULL character.  This value is a constant.
     * * A port's full name contains the owning client name concatenated
     * with a colon (:) followed by its short name and a NULL
     * character.
     * Original signature : <code>int jack_port_name_size()</code>
     * <i>native declaration : jack/jack.h:863</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z19jack_port_name_sizev", "?jack_port_name_size@@YAHXZ"})
    int jack_port_name_size();

    /**
     * @return the maximum number of characters in a JACK port type name
     * including the final NULL character.  This value is a constant.
     * Original signature : <code>int jack_port_type_size()</code>
     * <i>native declaration : jack/jack.h:869</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z19jack_port_type_sizev", "?jack_port_type_size@@YAHXZ"})
    int jack_port_type_size();

    /**
     * @return the sample rate of the jack system, as set by the user when
     * jackd was started.
     * Original signature : <code>jack_nframes_t jack_get_sample_rate(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:875</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z20jack_get_sample_rateP12_jack_client", "?jack_get_sample_rate@@YA8uint32_tPA12_jack_client@Z"})
    int jack_get_sample_rate(_jack_client jack_client_tPtr1);

    /**
     * @return the current maximum size that will ever be passed to the @a
     * process_callback.  It should only be used *before* the client has
     * been activated.  This size may change, clients that depend on it
     * must register a @a bufsize_callback so they will be notified if it
     * does.
     * * @see jack_set_buffer_size_callback()
     * Original signature : <code>jack_nframes_t jack_get_buffer_size(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:886</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z20jack_get_buffer_sizeP12_jack_client", "?jack_get_buffer_size@@YA8uint32_tPA12_jack_client@Z"})
    int jack_get_buffer_size(_jack_client jack_client_tPtr1);

    /**
     * @param port_name_pattern A regular expression used to select
     * ports by name.  If NULL or of zero length, no selection based
     * on name will be carried out.
     * @param type_name_pattern A regular expression used to select
     * ports by type.  If NULL or of zero length, no selection based
     * on type will be carried out.
     * @param flags A value used to select ports by their flags.
     * If zero, no selection based on flags will be carried out.
     * * @return a NULL-terminated array of ports that match the specified
     * arguments.  The caller is responsible for calling free(3) any
     * non-NULL returned value.
     * * @see jack_port_name_size(), jack_port_type_size()
     * Original signature : <code>char** jack_get_ports(jack_client_t*, const char*, const char*, unsigned long)</code>
     * <i>native declaration : jack/jack.h:904</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z14jack_get_portsP12_jack_clientPKcPKcm", "?jack_get_ports@@YAPAPADPA12_jack_clientPADPADK@Z"})
//    com.sun.jna.ptr.PointerByReference jack_get_ports(_jack_client jack_client_tPtr1, java.lang.String port_name_pattern, java.lang.String type_name_pattern, com.sun.jna.NativeLong flags);
    Pointer jack_get_ports(_jack_client jack_client_tPtr1, java.lang.String port_name_pattern, java.lang.String type_name_pattern, com.sun.jna.NativeLong flags);

    /**
     * @return address of the jack_port_t named @a port_name.
     * * @see jack_port_name_size()
     * Original signature : <code>jack_port_t* jack_port_by_name(jack_client_t*, const char*)</code>
     * <i>native declaration : jack/jack.h:914</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z17jack_port_by_nameP12_jack_clientPKc", "?jack_port_by_name@@YAPA10_jack_portPA12_jack_clientPAD@Z"})
    _jack_port jack_port_by_name(_jack_client jack_client_tPtr1, java.lang.String port_name);

    /**
     * @return address of the jack_port_t of a @a port_id.
     * Original signature : <code>jack_port_t* jack_port_by_id(jack_client_t*, jack_port_id_t)</code>
     * <i>native declaration : jack/jack.h:919</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z15jack_port_by_idP12_jack_client8uint32_t", "?jack_port_by_id@@YAPA10_jack_portPA12_jack_client8uint32_t@Z"})
    _jack_port jack_port_by_id(_jack_client client, int port_id);

    /**
     * @return the time in frames that has passed since the JACK server
     * began the current process cycle.
     * Original signature : <code>jack_nframes_t jack_frames_since_cycle_start(const jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:938</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z29jack_frames_since_cycle_startPK12_jack_client", "?jack_frames_since_cycle_start@@YA8uint32_tPA12_jack_client@Z"})
    int jack_frames_since_cycle_start(_jack_client jack_client_tPtr1);

    /**
     * @return an estimate of the current time in frames.  This is a
     * running counter, no significance should be attached to its value,
     * but it can be compared to a previously returned value.
     * Original signature : <code>jack_nframes_t jack_frame_time(const jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:945</i>
     */
    int jack_frame_time(_jack_client jack_client_tPtr1);

    /**
     * @return the frame_time after the last processing of the graph
     * this is only to be used from the process callback.
     * * This function can be used to put timestamps generated by
     * jack_frame_time() in correlation to the current process cycle.
     * Original signature : <code>jack_nframes_t jack_last_frame_time(const jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:954</i>
     */
    int jack_last_frame_time(_jack_client client);

    /**
     * <i>native declaration : jack/jack.h:959</i>
     * Conversion Error : _jack_time_t
     */
    /**
     * @return estimated time in frames for the specified system time.
     * Original signature : <code>jack_nframes_t jack_time_to_frames(const jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:964</i>
     */
    int jack_time_to_frames(_jack_client client);

    /**
     * <i>native declaration : jack/jack.h:974</i>
     * Conversion Error : _jack_time_t
     */
    /**
     * @return the current CPU load estimated by JACK.  This is a running
     * average of the time it takes to execute a full process cycle for
     * all clients as a percentage of the real time available per cycle
     * determined by the buffer size and sample rate.
     * Original signature : <code>float jack_cpu_load(jack_client_t*)</code>
     * <i>native declaration : jack/jack.h:982</i>
     */
    // @com.ochafik.lang.jnaerator.Mangling({"_Z13jack_cpu_loadP12_jack_client", "?jack_cpu_load@@YAMPA12_jack_client@Z"})
    float jack_cpu_load(_jack_client client);

    /**
     * <i>native declaration : jack/jack.h:988</i>
     * Conversion Error : pthread_t
     */
    /**
     * Set the @ref jack_error_callback for error message display.
     * * The JACK library provides two built-in callbacks for this purpose:
     * default_jack_error_callback() and silent_jack_error_callback().
     * Original signature : <code>void jack_set_error_function(func)</code>
     * <i>native declaration : jack/jack.h:1006</i>
     *
     * @param arg1
     */
    void jack_set_error_function(func arg1);

    /**
     * Set the @ref jack_info_callback for info message display.
     * Original signature : <code>void jack_set_info_function(func)</code>
     * <i>native declaration : jack/jack.h:1021</i>
     *
     * @param arg1
     */
    void jack_set_info_function(func arg1);

    /**
     * @return return JACK's current system time in microseconds,
     *         using JACK clock source.
     *
     * The value returned is guaranteed to be monotonic, but not linear.
     *
     * This function is a client version of @function jack_get_microseconds().
     */
    NativeLong jack_get_time();

    public static class _jack_client extends com.sun.jna.PointerType {

        public _jack_client(com.sun.jna.Pointer pointer) {
            super(pointer);
        }

        public _jack_client() {
            super();
        }
    }

    public static class _jack_port extends com.sun.jna.PointerType {

        public _jack_port(com.sun.jna.Pointer pointer) {
            super(pointer);
        }

        public _jack_port() {
            super();
        }
    }

//    void free(Pointer ptr);
    void jack_free(Pointer ptr);
}
